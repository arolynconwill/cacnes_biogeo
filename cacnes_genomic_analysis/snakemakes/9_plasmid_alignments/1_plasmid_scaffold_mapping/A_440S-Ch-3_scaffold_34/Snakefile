############################################
# LIEBERMAN LAB SNAKEFILE FOR MAPPING STEP #
############################################

# NOTE: only mapping steps specific to scaffold

# Version History:
# # 2020.06.24, Arolyn: cleaned up json and log file naming; added make_genomeFasta rule
# # 2020.02.20 JSB refurb. 
# # 2019.02.11, Arolyn: Added python function (split_samplesCSV.py; NOT a rule) so that Snakemake does not re-run ALL samples whenver samp.es.csv changes. The script to make mini csv files (breaks samples.csv line by line for each sample), and only updates them if samples.csv changed or if the sample didn't previously exist. 
# # 2019.02.08, Arolyn: Rewrote make_data_links so that concatenating and data links can be parallelized
# # 2018.12, Felix/Arolyn: Original Snakefile from the lab hackathon


## TODO
# - de-complex rules! each rule should do one step only. Overloaded rules can lead to unrecognized error. sam formatting, bam2vcf rules need to change!

# Reminders:
# # Put your own email address in cluster.slurm.json so that you get emails about failures. 



''' PRE-SNAKEMAKE '''

import sys
SCRIPTS_DIRECTORY = "/scratch/mit_lieberman/scripts"
sys.path.insert(0, SCRIPTS_DIRECTORY)

# from import read_samplesCSV # not needed since this function is in the next file
from read_move_link_samplesCSV import *


## Define couple of lists from samples.csv
## Format: Path,Sample,ReferenceGenome,ProviderName,Subject
spls = "samples.csv"
[PATH_ls, SAMPLE_ls, REF_Genome_ls, PROVIDER_ls, CLADEID_ls] = read_samplesCSV(spls)
# Write sample_info.csv for each sample
# print(REF_Genome_ls)
split_samplesCSV(PATH_ls,SAMPLE_ls,REF_Genome_ls,PROVIDER_ls,CLADEID_ls)
CLADES_ls = set(CLADEID_ls)

''' SNAKEMAKE '''
rule all:
    input:
    	# # Through all steps # #
        expand("/scratch/mit_lieberman/projects/aro_/2021_01_06_plasmid_big-set/reference_genomes_plasmids/{reference}/genome_bowtie2.1.bt2",reference=set(REF_Genome_ls)),
        expand("4-vcf/{sampleID}_ref_{reference}_aligned.sorted.strain.vcf.gz", zip, sampleID=SAMPLE_ls, reference=REF_Genome_ls),
        expand("5-quals/{sampleID}_ref_{reference}_aligned.sorted.strain.variant.quals.mat", zip, sampleID=SAMPLE_ls, reference=REF_Genome_ls),
        expand("6-diversity/{sampleID}_ref_{reference}_aligned.sorted.strain.variant.diversity.mat", zip, sampleID=SAMPLE_ls, reference=REF_Genome_ls),

rule refGenome_index: # NOTE: Change paths so that they point to where the plasmid fasta files are
	input:
		fasta="/scratch/mit_lieberman/projects/aro_/2021_01_06_plasmid_big-set/reference_genomes_plasmids/{reference}/genome.fasta"
	params:
		"/scratch/mit_lieberman/projects/aro_/2021_01_06_plasmid_big-set/reference_genomes_plasmids/{reference}/genome_bowtie2",
	output:
		bowtie2idx="/scratch/mit_lieberman/projects/aro_/2021_01_06_plasmid_big-set/reference_genomes_plasmids/{reference}/genome_bowtie2.1.bt2"
	conda:
		"envs/ll_bowtie2.yaml"
	shell:
		"bowtie2-build -q {input.fasta} {params} "

rule bowtie2:
	input:
		fq1="/scratch/mit_lieberman/projects/aro_/2021_01_06_plasmid_big-set/mapping_prep/1-data_processed/{sampleID}/filt1.fq.gz",#rules.sickle2050.output.fq1o,
		fq2="/scratch/mit_lieberman/projects/aro_/2021_01_06_plasmid_big-set/mapping_prep/1-data_processed/{sampleID}/filt2.fq.gz",#rules.sickle2050.output.fq2o,
		bowtie2idx=rules.refGenome_index.output.bowtie2idx # put here, so rule botie2 only executed after rule refGenome_index done
	params:
		refGenome="/scratch/mit_lieberman/projects/aro_/2021_01_06_plasmid_big-set/reference_genomes_plasmids/{reference}/genome_bowtie2",
		fqU="3-bowtie2/{sampleID}_ref_{reference}_unaligned.fastq", # just a prefix. 
	output:
		samA="3-bowtie2/{sampleID}_ref_{reference}_aligned.sam",
	conda:
		"envs/ll_bowtie2.yaml"
	shell:
		# 8 threads coded into json
		#"bowtie2 --threads 8 -X 2000 --no-mixed --dovetail --un-conc {params.fqU} -x {params.refGenome} -1 {input.fq1} -2 {input.fq2} -S {output.samA} "
		"bowtie2 --threads 8 -X 2000 --no-mixed --dovetail -x {params.refGenome} -1 {input.fq1} -2 {input.fq2} -S {output.samA} "

rule sam2bam:
	input:
		samA=rules.bowtie2.output.samA,
	params:
		fqU1="3-bowtie2/{sampleID}_ref_{reference}_unaligned.1.fastq",
		fqU2="3-bowtie2/{sampleID}_ref_{reference}_unaligned.2.fastq",
	output:
		bamA="3-bowtie2/{sampleID}_ref_{reference}_aligned.sorted.bam",
	conda:
		"envs/ll_samtools15_bcftools12.yaml"
	shell:
		# 8 threads coded into json
		" samtools view -bS {input.samA} | samtools sort - -o {output.bamA} ;"
		" samtools index {output.bamA} ;"
		#" bgzip -f {params.fqU1}; bgzip -f {params.fqU2};"
		" rm {input.samA} ;"

rule mpileup2vcf:
	input:
		bamA=rules.sam2bam.output.bamA,
		ref="/scratch/mit_lieberman/projects/aro_/2021_01_06_plasmid_big-set/reference_genomes_plasmids/{reference}/genome.fasta"
	output:
		pileup="4-vcf/{sampleID}_ref_{reference}_aligned.sorted.pileup",
		variants="4-vcf/{sampleID}_ref_{reference}_aligned.sorted.strain.variant.vcf.gz",
		vcf_strain="4-vcf/{sampleID}_ref_{reference}_aligned.sorted.strain.vcf.gz",
	params:
		vcf_raw="4-vcf/{sampleID}_ref_{reference}_aligned.sorted.strain.gz",
	conda:
		"envs/ll_samtools15_bcftools12.yaml"
	shell:
		" samtools faidx {input.ref} ; "
		" samtools mpileup -q30 -x -s -O -d3000 -f {input.ref} {input.bamA} > {output.pileup} ;" 
		" samtools mpileup -q30 -t SP -d3000 -vf {input.ref} {input.bamA} > {params.vcf_raw} ;"
		" bcftools call -c -Oz -o {output.vcf_strain} {params.vcf_raw} ;"
		" bcftools view -Oz -v snps -q .75 {output.vcf_strain} > {output.variants} ;"
		" tabix -p vcf {output.variants} ;"
		" rm {params.vcf_raw}"

# strain.vcf ==> vcf_to_quals.m ==> quals.mat
rule vcf2quals:
	input:
		vcf_strain = rules.mpileup2vcf.output.vcf_strain,
	params:
		refGenomeDir="/scratch/mit_lieberman/projects/aro_/2021_01_06_plasmid_big-set/reference_genomes_plasmids/{reference}/" # NOTE: Again, keep path consistent with wherever your reference is
	output:
		file_quals = "5-quals/{sampleID}_ref_{reference}_aligned.sorted.strain.variant.quals.mat", 
	shell:
		"""
		module add mit/matlab/2015b; 
		matlab -r "path('{SCRIPTS_DIRECTORY}',path); vcf_to_quals_snakemake( '{input.vcf_strain}', '{output.file_quals}', '{params.refGenomeDir}' )"
		"""

# strain.pileup ==> pileup_to_diversity.m ==> diversity.mat
rule pileup2diversity_matrix:
	input:
		pileup = rules.mpileup2vcf.output.pileup,
	params:
		refGenomeDir="/scratch/mit_lieberman/projects/aro_/2021_01_06_plasmid_big-set/reference_genomes_plasmids/{reference}/", # NOTE: Again, keep path consistent with wherever your reference is
	output:
		file_diversity = "6-diversity/{sampleID}_ref_{reference}_aligned.sorted.strain.variant.diversity.mat",
		file_coverage = "6-diversity/{sampleID}_ref_{reference}_aligned.sorted.strain.variant.coverage.mat",
	shell:
		"""
		module add mit/matlab/2015b; 
		matlab -r "path('{SCRIPTS_DIRECTORY}',path); pileup_to_diversity_matrix_snakemake( '{input.pileup}', '{output.file_diversity}', '{output.file_coverage}', '{params.refGenomeDir}' )" ;
		rm {input.pileup};
		"""






